CCS PCM C Compiler, Version 4.104, 5967               09-Jul-16 00:25

               Filename: C:\Users\Nahuel\Documents\GitHub\microcontroladores\graffitiRobot\graffitiRobotSlave\2SlaveUpRight\graffitiRobotSlave2.lst

               ROM used: 285 words (3%)
                         Largest free fragment is 2048
               RAM used: 19 (5%) at main() level
                         22 (6%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   08F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.3
001A:  GOTO   01D
001B:  BTFSC  0C.3
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   03D
.................... #include "C:\Users\Nahuel\Documents\GitHub\microcontroladores\graffitiRobot\graffitiRobotSlave\2SlaveUpRight\graffitiRobotSlave2.h" 
.................... #include <16F886.h> 
.................... //////// Standard Header file for the PIC16F886 device //////////////// 
.................... #device PIC16F886 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES IESO                  	//Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                 	//Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES BORV40                	//Brownout reset at 4.0V 
.................... #FUSES RESERVED              	//Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock=20000000) 
.................... #use i2c(Slave,Fast,sda=PIN_C4,scl=PIN_C3,address=0x20) 
*
0052:  MOVF   30,W
0053:  MOVWF  13
0054:  BSF    14.4
0055:  BCF    0C.3
0056:  BSF    03.5
0057:  BTFSC  14.0
0058:  GOTO   057
0059:  CLRF   78
005A:  BCF    03.5
005B:  BTFSC  14.4
005C:  INCF   78,F
....................  
.................... #BYTE PORTA = 0x05 
.................... #BYTE TRISA = 0x85 
....................  
.................... #BYTE PORTB = 0x06 
.................... #BYTE TRISB = 0x86 
....................  
.................... #bit PORTC0 = 0x07.0 
.................... #bit TRISC0 = 0x87.0 
.................... #bit PORTC1 = 0x07.1 
.................... #bit TRISC1 = 0x87.1 
.................... #bit PORTC2 = 0x07.2 
.................... #bit TRISC2 = 0x87.2 
....................  
....................  
.................... unsigned int8 estado;               //variable de estado del master 
.................... unsigned int8 estadoAnterior;       //variable que lleva el registro del estado anterior del master 
.................... const int8 STEP[] = {0x01,0x03,0x02,0x06,0x04,0x0B,0x07,0x08}; 
.................... byte fstate;                     //Guardara el estado del bus I2C 
.................... int8 numero; 
.................... char orden; 
....................  
.................... /*****************************************************************************/ 
.................... /********************** FUNCION INTERPRETA COMANDOS I2C *********************/ 
.................... /**        interpreta los comandos contenidos en la cadena comando[]        **/ 
....................  
.................... void interpreta() 
.................... { 
....................    //unsigned int16 aux16=0; 
....................    switch(orden) 
....................    { 
*
006F:  MOVF   2C,W
0070:  XORLW  70
0071:  BTFSC  03.2
0072:  GOTO   07D
0073:  XORLW  20
0074:  BTFSC  03.2
0075:  GOTO   07D
0076:  XORLW  24
0077:  BTFSC  03.2
0078:  GOTO   08A
0079:  XORLW  20
007A:  BTFSC  03.2
007B:  GOTO   08A
007C:  GOTO   08B
....................       case 'p': 
....................       case 'P': 
....................          switch(numero) 
....................          { 
007D:  MOVF   2B,W
007E:  BTFSC  03.2
007F:  GOTO   084
0080:  XORLW  01
0081:  BTFSC  03.2
0082:  GOTO   086
0083:  GOTO   089
....................             case 0x00: 
....................                estado = 0x00; 
0084:  CLRF   28
....................                break; 
0085:  GOTO   089
....................             case 0x01: 
....................                estado = 0x01; 
0086:  MOVLW  01
0087:  MOVWF  28
....................                break; 
0088:  GOTO   089
....................          } 
....................          break; 
0089:  GOTO   08B
....................       case 't': 
....................       case 'T': 
....................          //aux16=get16(1); 
....................          //if(aux16<60000) tpaso=aux16; 
....................          break; 
008A:  GOTO   08B
....................    } 
.................... } 
.................... /* 
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................  
.................... }*/ 
....................  
.................... /******************************************************************************/ 
.................... /***************** FUNCIÓN INTERRUPCIÓN POR RECEPCION I2C *********************/ 
.................... /**  Saltará a esta función cada vez que se detecte actividad en el bus I2C  **/ 
....................  
.................... #int_SSP 
.................... void  SSP_isr(void)  
.................... { 
....................    int incoming;                    //Variable donde se recibe el byte que manda el maestro 
....................    fstate = i2c_isr_state();           //Lectura del estado del bus I2c la interrupción 
*
003D:  BSF    03.5
003E:  BTFSC  14.5
003F:  GOTO   048
0040:  BCF    03.5
0041:  CLRF   2D
0042:  BSF    03.5
0043:  BTFSS  14.2
0044:  GOTO   048
0045:  BCF    03.5
0046:  BSF    2D.7
0047:  BSF    03.5
0048:  BCF    03.5
0049:  MOVF   2D,W
004A:  INCF   2D,F
004B:  MOVWF  2A
....................    /* Solicitud de lectura del esclavo por el master */ 
....................    if(fstate == 0x80) {          
004C:  MOVF   2A,W
004D:  SUBLW  80
004E:  BTFSS  03.2
004F:  GOTO   05E
....................       i2c_write(estado);               //Manda al maestro el estado del esclavo 
0050:  MOVF   28,W
0051:  MOVWF  30
....................    } 
....................    /* Sino está solicitando lectura es que está enviando algo */ 
....................    else {                           //Sino es que hay dato en el bus I2C... 
*
005D:  GOTO   08B
....................       incoming = i2c_read();           //... lo lee 
005E:  BCF    14.6
005F:  BTFSS  0C.3
0060:  GOTO   05F
0061:  MOVF   13,W
0062:  BSF    14.4
0063:  MOVWF  2F
....................       if (fstate == 1) {               //Información recibida corresponde a la posicion 
0064:  DECFSZ 2A,W
0065:  GOTO   069
....................          orden = incoming;          //Se guarda posición 
0066:  MOVF   2F,W
0067:  MOVWF  2C
....................       } 
....................       else if (fstate == 2) {          //Información recibida corresponde al dato 
0068:  GOTO   08B
0069:  MOVF   2A,W
006A:  SUBLW  02
006B:  BTFSS  03.2
006C:  GOTO   08B
....................          numero = incoming;         //Se guarda dato 
006D:  MOVF   2F,W
006E:  MOVWF  2B
....................          interpreta(); 
....................       } 
....................    } 
.................... } 
....................  
....................  
....................  
*
008B:  BCF    0C.3
008C:  BCF    0A.3
008D:  BCF    0A.4
008E:  GOTO   01D
.................... void main() 
.................... { 
008F:  CLRF   04
0090:  BCF    03.7
0091:  MOVLW  1F
0092:  ANDWF  03,F
0093:  BSF    27.3
0094:  MOVF   27,W
0095:  BSF    03.5
0096:  MOVWF  07
0097:  BCF    03.5
0098:  BSF    27.4
0099:  MOVF   27,W
009A:  BSF    03.5
009B:  MOVWF  07
009C:  MOVLW  20
009D:  MOVWF  13
009E:  MOVLW  36
009F:  BCF    03.5
00A0:  MOVWF  14
00A1:  BSF    03.5
00A2:  BSF    03.6
00A3:  MOVF   09,W
00A4:  ANDLW  C0
00A5:  MOVWF  09
00A6:  BCF    03.6
00A7:  BCF    1F.4
00A8:  BCF    1F.5
00A9:  MOVLW  00
00AA:  BSF    03.6
00AB:  MOVWF  08
00AC:  BCF    03.5
00AD:  CLRF   07
00AE:  CLRF   08
00AF:  CLRF   09
....................    TRISA = 0x00; 
*
00B5:  BSF    03.5
00B6:  CLRF   05
....................    TRISB = 0x00; 
00B7:  CLRF   06
....................    TRISC0 = 1; 
00B8:  BSF    07.0
....................    TRISC1 = 1; 
00B9:  BSF    07.1
....................    TRISC2 = 0; 
00BA:  BCF    07.2
....................  
....................    estado = 0x00;                //Representa el estado del master 
00BB:  BCF    03.5
00BC:  CLRF   28
....................    estadoAnterior = 0x01;        //Definido con un valor diferente a estado solo a fines de que pase por el primer bucle de desenergizado 
00BD:  MOVLW  01
00BE:  MOVWF  29
....................     
....................    unsigned int stepIndex = 0; 
00BF:  CLRF   2E
....................  
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD);    setup_adc(ADC_CLOCK_DIV_2); 
00C0:  BSF    03.5
00C1:  BSF    03.6
00C2:  MOVF   09,W
00C3:  ANDLW  C0
00C4:  MOVWF  09
00C5:  BCF    03.6
00C6:  BCF    1F.4
00C7:  BCF    1F.5
00C8:  MOVLW  00
00C9:  BSF    03.6
00CA:  MOVWF  08
00CB:  BCF    03.5
00CC:  BCF    03.6
00CD:  BCF    1F.6
00CE:  BCF    1F.7
00CF:  BSF    03.5
00D0:  BCF    1F.7
00D1:  BCF    03.5
00D2:  BSF    1F.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
00D3:  BSF    03.5
00D4:  MOVF   01,W
00D5:  ANDLW  C7
00D6:  IORLW  08
00D7:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
00D8:  MOVLW  05
00D9:  BCF    03.5
00DA:  MOVWF  10
....................    setup_timer_2(T2_DISABLED,0,1); 
00DB:  MOVLW  00
00DC:  MOVWF  78
00DD:  MOVWF  12
00DE:  MOVLW  00
00DF:  BSF    03.5
00E0:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC);// This device COMP currently not supported by the PICWizard 
00E1:  BCF    03.5
00E2:  BSF    03.6
00E3:  CLRF   07
00E4:  CLRF   08
00E5:  CLRF   09
.................... // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_SSP); 
00E6:  BSF    03.5
00E7:  BCF    03.6
00E8:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
00E9:  MOVLW  C0
00EA:  BCF    03.5
00EB:  IORWF  0B,F
.................... //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
....................  
....................    for (;;) 
....................    { 
....................       switch(estado) 
....................       { 
00EC:  MOVF   28,W
00ED:  BTFSC  03.2
00EE:  GOTO   102
00EF:  XORLW  01
00F0:  BTFSC  03.2
00F1:  GOTO   10A
00F2:  XORLW  02
00F3:  BTFSC  03.2
00F4:  GOTO   116
00F5:  XORLW  06
00F6:  BTFSC  03.2
00F7:  GOTO   117
00F8:  XORLW  08
00F9:  BTFSC  03.2
00FA:  GOTO   118
00FB:  XORLW  18
00FC:  BTFSC  03.2
00FD:  GOTO   119
00FE:  XORLW  28
00FF:  BTFSC  03.2
0100:  GOTO   11A
0101:  GOTO   11B
....................          case 0x00:              //Solicitar desenergizar motores a los esclavos 
....................             if(estadoAnterior & 0x01) 
0102:  BTFSS  29.0
0103:  GOTO   109
....................             { 
....................                estadoAnterior = estado; 
0104:  MOVF   28,W
0105:  MOVWF  29
....................                PORTB = 0x00; 
0106:  CLRF   06
....................                PORTA = estado; 
0107:  MOVF   28,W
0108:  MOVWF  05
....................             } 
....................             break; 
0109:  GOTO   11B
....................          case 0x01:              //Solicitar energizar motores a los esclavos 
....................             if (estadoAnterior == 0x00) 
010A:  MOVF   29,F
010B:  BTFSS  03.2
010C:  GOTO   115
....................             { 
....................                estadoAnterior = estado; 
010D:  MOVF   28,W
010E:  MOVWF  29
....................                PORTB = STEP[stepIndex]; 
010F:  MOVF   2E,W
0110:  CALL   031
0111:  MOVWF  78
0112:  MOVWF  06
....................                PORTA = estado; 
0113:  MOVF   28,W
0114:  MOVWF  05
....................             } 
....................             break; 
0115:  GOTO   11B
....................          case 0x03:              //Solicitar hacer homing a los esclavos 
....................             break; 
0116:  GOTO   11B
....................          case 0x05:              //Esperando ordenes de dibujo (Punto de Inicio y Punto de Final) 
....................             break; 
0117:  GOTO   11B
....................          case 0x0D:              //Enviar coordenadas de inicio a los esclavos 
....................             break; 
0118:  GOTO   11B
....................          case 0x15:              //Enviar valor de interrupcion de timer a los esclavos 
....................             break; 
0119:  GOTO   11B
....................          case 0x3D:              //Enviar coordenadas de final a los esclavos 
....................             break; 
011A:  GOTO   11B
....................       } 
....................    } 
011B:  GOTO   0EC
.................... } 
011C:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
