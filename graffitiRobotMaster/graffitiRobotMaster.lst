CCS PCM C Compiler, Version 4.104, 5967               08-Jul-16 20:11

               Filename: c:\users\nahuel\documents\github\microcontroladores\graffitirobot\graffitirobotmaster\graffitiRobotMaster.lst

               ROM used: 555 words (7%)
                         Largest free fragment is 2048
               RAM used: 37 (10%) at main() level
                         44 (12%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   176
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   034
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.3
0020:  GOTO   023
0021:  BTFSC  0C.3
0022:  GOTO   037
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   20,W
002E:  MOVWF  0A
002F:  SWAPF  21,W
0030:  MOVWF  03
0031:  SWAPF  7F,F
0032:  SWAPF  7F,W
0033:  RETFIE
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   03A
0037:  BCF    0A.3
0038:  BCF    0A.4
0039:  GOTO   080
.................... #include "C:\Users\Nahuel\Documents\GitHub\microcontroladores\graffitiRobot\graffitiRobotMaster\graffitiRobotMaster.h" 
.................... #include <16F886.h> 
.................... //////// Standard Header file for the PIC16F886 device //////////////// 
.................... #device PIC16F886 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock=20000000) 
*
0162:  MOVLW  43
0163:  MOVWF  04
0164:  BCF    03.7
0165:  MOVF   00,W
0166:  BTFSC  03.2
0167:  GOTO   175
0168:  MOVLW  06
0169:  MOVWF  78
016A:  CLRF   77
016B:  DECFSZ 77,F
016C:  GOTO   16B
016D:  DECFSZ 78,F
016E:  GOTO   16A
016F:  MOVLW  7B
0170:  MOVWF  77
0171:  DECFSZ 77,F
0172:  GOTO   171
0173:  DECFSZ 00,F
0174:  GOTO   168
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
*
00DE:  MOVLW  08
00DF:  MOVWF  78
00E0:  NOP
00E1:  BCF    07.3
00E2:  BCF    27.3
00E3:  MOVF   27,W
00E4:  BSF    03.5
00E5:  MOVWF  07
00E6:  NOP
00E7:  BCF    03.5
00E8:  RLF    43,F
00E9:  BCF    07.4
00EA:  BTFSS  03.0
00EB:  GOTO   0F2
00EC:  BSF    27.4
00ED:  MOVF   27,W
00EE:  BSF    03.5
00EF:  MOVWF  07
00F0:  GOTO   0F6
00F1:  BCF    03.5
00F2:  BCF    27.4
00F3:  MOVF   27,W
00F4:  BSF    03.5
00F5:  MOVWF  07
00F6:  NOP
00F7:  BCF    03.5
00F8:  BSF    27.3
00F9:  MOVF   27,W
00FA:  BSF    03.5
00FB:  MOVWF  07
00FC:  BCF    03.5
00FD:  BTFSS  07.3
00FE:  GOTO   0FD
00FF:  DECFSZ 78,F
0100:  GOTO   0E0
0101:  NOP
0102:  BCF    07.3
0103:  BCF    27.3
0104:  MOVF   27,W
0105:  BSF    03.5
0106:  MOVWF  07
0107:  NOP
0108:  BCF    03.5
0109:  BSF    27.4
010A:  MOVF   27,W
010B:  BSF    03.5
010C:  MOVWF  07
010D:  NOP
010E:  NOP
010F:  BCF    03.5
0110:  BSF    27.3
0111:  MOVF   27,W
0112:  BSF    03.5
0113:  MOVWF  07
0114:  BCF    03.5
0115:  BTFSS  07.3
0116:  GOTO   115
0117:  CLRF   78
0118:  NOP
0119:  BTFSC  07.4
011A:  BSF    78.0
011B:  BCF    07.3
011C:  BCF    27.3
011D:  MOVF   27,W
011E:  BSF    03.5
011F:  MOVWF  07
0120:  BCF    03.5
0121:  BCF    07.4
0122:  BCF    27.4
0123:  MOVF   27,W
0124:  BSF    03.5
0125:  MOVWF  07
0126:  BCF    03.5
0127:  RETURN
....................  
.................... #define LONGI_BUF   20 
....................  
.................... #BYTE PORTA = 0x05 
.................... #BYTE TRISA = 0x85 
....................  
.................... #BYTE PORTB = 0x06 
.................... #BYTE TRISB = 0x86 
....................  
....................  
.................... char comando[LONGI_BUF];            // array para recibir las cadenas de caracteres de los comandos (buffer de recepci贸n) 
.................... unsigned int8 i;                     // -indice para apuntar a los elementos dentro del array comando[] 
.................... unsigned int8 cmd;                  // -Flag para indicar que se hay recepci贸n de mensaje en curso (para evitar interpretar 
.................... unsigned int8 estado;               //variable de estado del master 
.................... unsigned int8 estadoAnterior;        //variable que lleva el registro del estado anterior del master 
....................  
.................... /* get16(k) - Funcin auxiliar que devuelve el valor numrico (int16) de una cadena decimal  
.................... a partir del elemento k hasta encontrar el caracter null (similar a atoi o atol)*/ 
.................... unsigned int16 get16(int k) 
.................... { 
.................... 	unsigned int16 aux16=0; 
.................... 	while(comando[k]!=0)  // despus de la cadena decimal hay un caracter null (ASCII 0) 
.................... 	{ 
.................... 		aux16=aux16*10+comando[k]-'0'; //'0' es 48 en decimal o 0x30 en hexa  
.................... 		k++;    
.................... 	}   
.................... 	return aux16; 
.................... } 
....................     
.................... /*****************************************************************************/ 
.................... /********************** FUNCION INTERPRETA COMANDOS UART *********************/ 
.................... /**        interpreta los comandos contenidos en la cadena comando[]        **/ 
....................  
.................... void interpreta() 
.................... { 
.................... 	//unsigned int16 aux16=0; 
.................... 	switch(comando[0]) 
.................... 	{ 
*
0051:  MOVF   28,W
0052:  XORLW  70
0053:  BTFSC  03.2
0054:  GOTO   05F
0055:  XORLW  20
0056:  BTFSC  03.2
0057:  GOTO   05F
0058:  XORLW  24
0059:  BTFSC  03.2
005A:  GOTO   06D
005B:  XORLW  20
005C:  BTFSC  03.2
005D:  GOTO   06D
005E:  GOTO   06E
.................... 		case 'p': 
.................... 		case 'P': 
.................... 			switch(comando[1]) 
.................... 			{ 
005F:  MOVF   29,W
0060:  XORLW  30
0061:  BTFSC  03.2
0062:  GOTO   067
0063:  XORLW  01
0064:  BTFSC  03.2
0065:  GOTO   069
0066:  GOTO   06C
.................... 				case '0': 
.................... 					estado = 0x00; 
0067:  CLRF   3E
.................... 					break; 
0068:  GOTO   06C
.................... 				case '1': 
.................... 				estado = 0x01; 
0069:  MOVLW  01
006A:  MOVWF  3E
.................... 				break; 
006B:  GOTO   06C
.................... 			} 
.................... 			break; 
006C:  GOTO   06E
.................... 		case 't': 
.................... 		case 'T': 
.................... 			//aux16=get16(1); 
.................... 			//if(aux16<60000) tpaso=aux16; 
.................... 			break; 
006D:  GOTO   06E
.................... 	} 
.................... } 
....................  
.................... /******************************************************************************/ 
.................... /******************* FUNCIN ESCRITURA EN PICS ESCLAVOS ***********************/ 
.................... /** Guarda un dato (n煤mero aleatorio) en la posici贸n de memoria indicada y en el  
....................           PIC correspondiente a la direcci贸n I2C proporcionada               **/ 
....................  
.................... void Envio_I2C(direccion, caracter, numero) 
.................... { 
.................... 	i2c_start();               // Comienzo comunicaci贸n 
*
0128:  BSF    27.4
0129:  MOVF   27,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  NOP
012D:  BCF    03.5
012E:  BSF    27.3
012F:  MOVF   27,W
0130:  BSF    03.5
0131:  MOVWF  07
0132:  NOP
0133:  BCF    03.5
0134:  BCF    07.4
0135:  BCF    27.4
0136:  MOVF   27,W
0137:  BSF    03.5
0138:  MOVWF  07
0139:  NOP
013A:  BCF    03.5
013B:  BCF    07.3
013C:  BCF    27.3
013D:  MOVF   27,W
013E:  BSF    03.5
013F:  MOVWF  07
.................... 	i2c_write(direccion);      // Direcci贸n del esclavo en el bus I2C 
0140:  BCF    03.5
0141:  MOVF   40,W
0142:  MOVWF  43
0143:  CALL   0DE
.................... 	i2c_write(caracter);      // Caracter representativo del comando solicitado 
0144:  MOVF   41,W
0145:  MOVWF  43
0146:  CALL   0DE
.................... 	i2c_write(numero);      // Numero complemento del comando 
0147:  MOVF   42,W
0148:  MOVWF  43
0149:  CALL   0DE
.................... 	i2c_stop();                // Fin comunicaci贸n 
014A:  BCF    27.4
014B:  MOVF   27,W
014C:  BSF    03.5
014D:  MOVWF  07
014E:  NOP
014F:  BCF    03.5
0150:  BSF    27.3
0151:  MOVF   27,W
0152:  BSF    03.5
0153:  MOVWF  07
0154:  BCF    03.5
0155:  BTFSS  07.3
0156:  GOTO   155
0157:  NOP
0158:  GOTO   159
0159:  NOP
015A:  BSF    27.4
015B:  MOVF   27,W
015C:  BSF    03.5
015D:  MOVWF  07
015E:  NOP
.................... 	delay_ms(50); 
015F:  MOVLW  32
0160:  BCF    03.5
0161:  MOVWF  43
.................... } 
*
0175:  RETURN
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
.................... 	char dato; 
.................... 	dato = getc(); 
*
003A:  BTFSS  0C.5
003B:  GOTO   03A
003C:  MOVF   1A,W
003D:  MOVWF  44
.................... 	switch(dato) 
.................... 	{ 
003E:  MOVF   44,W
003F:  XORLW  3A
0040:  BTFSC  03.2
0041:  GOTO   046
0042:  XORLW  37
0043:  BTFSC  03.2
0044:  GOTO   04A
0045:  GOTO   070
.................... 		case ':':						//si es delimitador de inicio  
.................... 			i = 0;						//inicializa contador i 
0046:  CLRF   3C
.................... 			cmd = 1;					//y activa bandera que indica que hay comando en curso 
0047:  MOVLW  01
0048:  MOVWF  3D
.................... 			break;       
0049:  GOTO   07C
.................... 		case 13:						//si es delimitador de final  
.................... 			if (cmd == 1)				// si hab铆a comando en curso 
004A:  DECFSZ 3D,W
004B:  GOTO   06F
.................... 			{ 
.................... 				comando[i] = 0;			//termina cadena de comando con caracter null 
004C:  MOVLW  28
004D:  ADDWF  3C,W
004E:  MOVWF  04
004F:  BCF    03.7
0050:  CLRF   00
.................... 				interpreta();			//va a interpretar el comando 
.................... 				cmd = 0;				//desactiva bandera de comando en curso 
*
006E:  CLRF   3D
.................... 			} 
.................... 			break; 
006F:  GOTO   07C
.................... 		default: 
.................... 			if (i < LONGI_BUF)			//si contador menor que longitud del buffer 
0070:  MOVF   3C,W
0071:  SUBLW  13
0072:  BTFSS  03.0
0073:  GOTO   07B
.................... 			{ 
.................... 				comando[i] = dato;		//pone caracter en cadena 
0074:  MOVLW  28
0075:  ADDWF  3C,W
0076:  MOVWF  04
0077:  BCF    03.7
0078:  MOVF   44,W
0079:  MOVWF  00
.................... 				i++;					//incrementa contador i 
007A:  INCF   3C,F
.................... 			} 
.................... 			break; 
007B:  GOTO   07C
.................... 	} 
.................... } 
....................  
007C:  BCF    0C.5
007D:  BCF    0A.3
007E:  BCF    0A.4
007F:  GOTO   023
.................... #int_SSP 
.................... void  SSP_isr(void)  
.................... { 
....................  
.................... } 
....................  
....................  
....................  
0080:  BCF    0C.3
0081:  BCF    0A.3
0082:  BCF    0A.4
0083:  GOTO   023
.................... void main() 
.................... { 
*
0176:  CLRF   04
0177:  BCF    03.7
0178:  MOVLW  1F
0179:  ANDWF  03,F
017A:  BSF    03.5
017B:  BSF    03.6
017C:  BSF    07.3
017D:  MOVLW  08
017E:  BCF    03.6
017F:  MOVWF  19
0180:  MOVLW  02
0181:  MOVWF  1A
0182:  MOVLW  A6
0183:  MOVWF  18
0184:  MOVLW  90
0185:  BCF    03.5
0186:  MOVWF  18
0187:  BSF    03.5
0188:  BSF    03.6
0189:  MOVF   09,W
018A:  ANDLW  C0
018B:  MOVWF  09
018C:  BCF    03.6
018D:  BCF    1F.4
018E:  BCF    1F.5
018F:  MOVLW  00
0190:  BSF    03.6
0191:  MOVWF  08
0192:  BCF    03.5
0193:  CLRF   07
0194:  CLRF   08
0195:  CLRF   09
.................... 	/* Definicion de variables */ 
.................... 	estado = 0x00;						//Representa el estado del master 
*
0199:  CLRF   3E
.................... 	estadoAnterior = 0x01;				//Definido con un valor diferente a estado solo a fines de que pase por el primer bucle de desenergizado 
019A:  MOVLW  01
019B:  MOVWF  3F
.................... 	TRISA = 0x00; 
019C:  BSF    03.5
019D:  CLRF   05
.................... 	TRISB = 0x06; 
019E:  MOVLW  06
019F:  MOVWF  06
....................     
.................... 	//char orden; 
....................  
.................... 	setup_adc_ports(NO_ANALOGS|VSS_VDD); 
01A0:  BSF    03.6
01A1:  MOVF   09,W
01A2:  ANDLW  C0
01A3:  MOVWF  09
01A4:  BCF    03.6
01A5:  BCF    1F.4
01A6:  BCF    1F.5
01A7:  MOVLW  00
01A8:  BSF    03.6
01A9:  MOVWF  08
.................... 	setup_adc(ADC_CLOCK_DIV_2); 
01AA:  BCF    03.5
01AB:  BCF    03.6
01AC:  BCF    1F.6
01AD:  BCF    1F.7
01AE:  BSF    03.5
01AF:  BCF    1F.7
01B0:  BCF    03.5
01B1:  BSF    1F.0
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
01B2:  BSF    03.5
01B3:  MOVF   01,W
01B4:  ANDLW  C7
01B5:  IORLW  08
01B6:  MOVWF  01
.................... 	setup_timer_1(T1_DISABLED); 
01B7:  BCF    03.5
01B8:  CLRF   10
.................... 	setup_timer_2(T2_DISABLED,0,1); 
01B9:  MOVLW  00
01BA:  MOVWF  78
01BB:  MOVWF  12
01BC:  MOVLW  00
01BD:  BSF    03.5
01BE:  MOVWF  12
.................... 	setup_comparator(NC_NC_NC_NC);		// This device COMP currently not supported by the PICWizard 
01BF:  BCF    03.5
01C0:  BSF    03.6
01C1:  CLRF   07
01C2:  CLRF   08
01C3:  CLRF   09
.................... 	enable_interrupts(INT_RDA); 
01C4:  BSF    03.5
01C5:  BCF    03.6
01C6:  BSF    0C.5
.................... 	enable_interrupts(INT_SSP); 
01C7:  BSF    0C.3
.................... 	enable_interrupts(GLOBAL); 
01C8:  MOVLW  C0
01C9:  BCF    03.5
01CA:  IORWF  0B,F
.................... //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
....................  
.................... 	printf("ok\r"); 
01CB:  MOVLW  6F
01CC:  BTFSS  0C.4
01CD:  GOTO   1CC
01CE:  MOVWF  19
01CF:  MOVLW  6B
01D0:  BTFSS  0C.4
01D1:  GOTO   1D0
01D2:  MOVWF  19
01D3:  MOVLW  0D
01D4:  BTFSS  0C.4
01D5:  GOTO   1D4
01D6:  MOVWF  19
.................... 	for (;;) 
.................... 	{ 
.................... 		switch(estado) 
.................... 		{ 
01D7:  MOVF   3E,W
01D8:  BTFSC  03.2
01D9:  GOTO   1ED
01DA:  XORLW  01
01DB:  BTFSC  03.2
01DC:  GOTO   207
01DD:  XORLW  02
01DE:  BTFSC  03.2
01DF:  GOTO   224
01E0:  XORLW  06
01E1:  BTFSC  03.2
01E2:  GOTO   225
01E3:  XORLW  08
01E4:  BTFSC  03.2
01E5:  GOTO   226
01E6:  XORLW  18
01E7:  BTFSC  03.2
01E8:  GOTO   227
01E9:  XORLW  28
01EA:  BTFSC  03.2
01EB:  GOTO   228
01EC:  GOTO   229
.................... 			case 0x00:					//Solicitar desenergizar motores a los esclavos 
.................... 				if(estadoAnterior & 0x01) 
01ED:  BTFSS  3F.0
01EE:  GOTO   206
.................... 				{ 
.................... 					estadoAnterior = estado; 
01EF:  MOVF   3E,W
01F0:  MOVWF  3F
.................... 					printf("Desenergizando...\r"); 
01F1:  MOVLW  84
01F2:  BSF    03.6
01F3:  MOVWF  0D
01F4:  MOVLW  00
01F5:  MOVWF  0F
01F6:  BCF    03.6
01F7:  CALL   096
.................... 					Envio_I2C(0x01 , 'P', 0); 
01F8:  MOVLW  01
01F9:  MOVWF  40
01FA:  MOVLW  50
01FB:  MOVWF  41
01FC:  CLRF   42
01FD:  CALL   128
.................... 					Envio_I2C(0x02 , 'P', 0); 
01FE:  MOVLW  02
01FF:  MOVWF  40
0200:  MOVLW  50
0201:  MOVWF  41
0202:  CLRF   42
0203:  CALL   128
.................... 					PORTA = estado; 
0204:  MOVF   3E,W
0205:  MOVWF  05
.................... 				} 
.................... 				break; 
0206:  GOTO   229
.................... 			case 0x01:					//Solicitar energizar motores a los esclavos 
.................... 				if (estadoAnterior == 0x00) 
0207:  MOVF   3F,F
0208:  BTFSS  03.2
0209:  GOTO   223
.................... 				{ 
.................... 					estadoAnterior = estado; 
020A:  MOVF   3E,W
020B:  MOVWF  3F
.................... 					printf("Energizando...\r"); 
020C:  MOVLW  8E
020D:  BSF    03.6
020E:  MOVWF  0D
020F:  MOVLW  00
0210:  MOVWF  0F
0211:  BCF    03.6
0212:  CALL   096
.................... 					Envio_I2C(0x01 , 'P', 1); 
0213:  MOVLW  01
0214:  MOVWF  40
0215:  MOVLW  50
0216:  MOVWF  41
0217:  MOVLW  01
0218:  MOVWF  42
0219:  CALL   128
.................... 					Envio_I2C(0x02 , 'P', 1); 
021A:  MOVLW  02
021B:  MOVWF  40
021C:  MOVLW  50
021D:  MOVWF  41
021E:  MOVLW  01
021F:  MOVWF  42
0220:  CALL   128
.................... 					PORTA = estado; 
0221:  MOVF   3E,W
0222:  MOVWF  05
.................... 				} 
.................... 				break; 
0223:  GOTO   229
.................... 			case 0x03:					//Solicitar hacer homing a los esclavos 
.................... 				break; 
0224:  GOTO   229
.................... 			case 0x05:					//Esperando ordenes de dibujo (Punto de Inicio y Punto de Final) 
.................... 				break; 
0225:  GOTO   229
.................... 			case 0x0D:					//Enviar coordenadas de inicio a los esclavos 
.................... 				break; 
0226:  GOTO   229
.................... 			case 0x15:					//Enviar valor de interrupcion de timer a los esclavos 
.................... 				break; 
0227:  GOTO   229
.................... 			case 0x3D:					//Enviar coordenadas de final a los esclavos 
.................... 				break; 
0228:  GOTO   229
.................... 			} 
.................... 	} 
0229:  GOTO   1D7
.................... } 
022A:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
